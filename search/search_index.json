{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to mesa-frames \ud83d\ude80","text":"<p>mesa-frames is an extension of the mesa framework, designed for complex simulations with thousands of agents. By storing agents in a DataFrame, mesa-frames significantly enhances the performance and scalability of mesa, while maintaining a similar syntax.</p> <p>You can get a model which is multiple orders of magnitude faster based on the number of agents - the more agents, the faster the relative performance.</p>"},{"location":"#why-dataframes","title":"Why DataFrames? \ud83d\udcca","text":"<p>DataFrames are optimized for simultaneous operations through SIMD processing. Currently, mesa-frames supports the library:</p> <ul> <li>Polars: A new DataFrame library with a Rust backend, offering innovations like Apache Arrow memory format and support for larger-than-memory DataFrames.</li> </ul>"},{"location":"#performance-boost","title":"Performance Boost \ud83c\udfce\ufe0f","text":"<p>Check out our performance graphs comparing mesa and mesa-frames for the Boltzmann Wealth model:</p> <p></p> <p></p>"},{"location":"#quick-start","title":"Quick Start \ud83d\ude80","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#installing-from-pypi","title":"Installing from PyPI","text":"<pre><code>pip install mesa-frames\n</code></pre>"},{"location":"#installing-from-source","title":"Installing from Source","text":"<pre><code>git clone https://github.com/projectmesa/mesa-frames.git\ncd mesa_frames\npip install -e .\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Here's a quick example of how to create a model using mesa-frames:</p> <pre><code>from mesa_frames import AgentSet, Model\nimport polars as pl\n\nclass MoneyAgents(AgentSet):\n    def __init__(self, n: int, model: Model):\n        super().__init__(model)\n        self += pl.DataFrame(\n            {\"wealth\": pl.ones(n, eager=True)}\n        )\n\n    def step(self) -&gt; None:\n        self.do(\"give_money\")\n\n    def give_money(self):\n        # ... (implementation details)\n\nclass MoneyModel(Model):\n    def __init__(self, N: int):\n        super().__init__()\n        self.sets += MoneyAgents(N, self)\n\n    def step(self):\n        self.sets.do(\"step\")\n\n    def run_model(self, n):\n        for _ in range(n):\n            self.step()\n</code></pre>"},{"location":"#whats-next","title":"What's Next? \ud83d\udd2e","text":"<ul> <li>API refinement for seamless transition from mesa</li> <li>Support for mesa functions</li> <li>Multiple other spaces: GeoGrid, ContinuousSpace, Network...</li> <li>Additional backends: Dask, cuDF (GPU), Dask-cuDF (GPU)...</li> <li>More examples: Schelling model, ...</li> <li>Automatic vectorization of existing mesa models</li> <li>Backend-agnostic AgentSet class</li> </ul>"},{"location":"#get-involved","title":"Get Involved! \ud83e\udd1d","text":"<p>mesa-frames is in its early stages, and we welcome your feedback and contributions! Check out our GitHub repository to get started.</p>"},{"location":"#license","title":"License","text":"<p>mesa-frames is available under the MIT License. See the LICENSE file for full details.</p>"},{"location":"contributing/","title":"Contributing to mesa-frames \ud83d\ude80","text":"<p>Thank you for taking the time to contribute to mesa-frames! Since the project is still in its early stages, we warmly welcome contributions that will help shape its development. \ud83c\udf89</p> <p>For a more general and comprehensive guide, please refer to mesa's main contribution guidelines. \ud83d\udcdc</p>"},{"location":"contributing/#project-roadmap","title":"Project Roadmap \ud83d\uddfa\ufe0f","text":"<p>Before contributing, we recommend reviewing our roadmap file to understand the project's current priorities, upcoming features, and long-term vision. This will help ensure your contributions align with the project's direction.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute \ud83d\udca1","text":""},{"location":"contributing/#1-prerequisite-installations","title":"1. Prerequisite Installations \u2699\ufe0f","text":"<p>Before you begin contributing, ensure that you have the necessary tools installed:</p> <ul> <li>Install Python (at least the version specified in <code>requires-python</code> of <code>pyproject.toml</code>). \ud83d\udc0d</li> <li>We recommend using a virtual environment manager like:</li> <li>Astral's UV \ud83c\udf1f</li> <li>Hatch \ud83c\udfd7\ufe0f</li> <li>Install pre-commit to enforce code quality standards before pushing changes:</li> <li>Pre-commit installation guide \u2705</li> <li>More about pre-commit hooks</li> <li>If using VS Code, consider installing these extensions to automatically enforce formatting:</li> <li>Ruff \u2013 Python linting &amp; formatting \ud83d\udc3e</li> <li>Markdownlint \u2013 Markdown linting (for documentation) \u270d\ufe0f</li> <li>Git Hooks \u2013 Automatically runs &amp; visualizes pre-commit hooks \ud83d\udd17</li> </ul>"},{"location":"contributing/#2-contribution-process","title":"2. Contribution Process \ud83d\udee0\ufe0f","text":""},{"location":"contributing/#step-1-choose-an-issue","title":"Step 1: Choose an Issue \ud83d\udccc","text":"<ul> <li>Pick an existing issue or create a new one if necessary.</li> <li>Ensure that your contribution aligns with the project's goals.</li> </ul>"},{"location":"contributing/#step-2-set-up-your-local-repository","title":"Step 2: Set Up Your Local Repository \ud83d\udcbb","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork to your local machine:</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/mesa-frames.git\n</code></pre> <ol> <li>Create a new branch with a descriptive name:</li> </ol> <pre><code>git checkout -b feature-name\n</code></pre> <ol> <li>Prevent merge commit clutter by setting rebase mode:</li> </ol> <pre><code>git config pull.rebase true\n</code></pre>"},{"location":"contributing/#step-3-install-dependencies","title":"Step 3: Install Dependencies \ud83d\udce6","text":"<p>It is recommended to set up a virtual environment before installing dependencies.</p> <ul> <li>Using UV:</li> </ul> <pre><code>uv add --dev .[dev]\n</code></pre> <ul> <li>Using Hatch:</li> </ul> <pre><code>hatch env create dev\n</code></pre> <ul> <li>Using Standard Python:</li> </ul> <pre><code>python3 -m venv myenv\nsource myenv/bin/activate  # macOS/Linux\nmyenv\\Scripts\\activate    # Windows\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#step-4-make-and-commit-changes","title":"Step 4: Make and Commit Changes \u2728","text":"<ol> <li>Make necessary edits and save the code.</li> <li>Add and commit your changes with meaningful commit messages:</li> </ol> <pre><code>git add FILE_NAME\ngit commit -m \"Fix issue X: Brief description of the fix\"\n</code></pre> <ul> <li>Keep commits small and focused on a single logical change.</li> <li>Follow Tim Pope\u2019s commit message guidelines. \ud83d\udcdd</li> </ul>"},{"location":"contributing/#step-5-code-quality-and-testing","title":"Step 5: Code Quality and Testing \u2705","text":"<ul> <li>Run pre-commit hooks to enforce code quality standards:</li> </ul> <pre><code>pre-commit run\n</code></pre> <ul> <li>Run tests to ensure your contribution does not break functionality:</li> </ul> <pre><code>pytest --cov\n</code></pre> <ul> <li> <p>If using UV: <code>uv run pytest --cov</code></p> </li> <li> <p>Optional: Enable runtime type checking during development for enhanced type safety:</p> </li> </ul> <pre><code>MESA_FRAMES_RUNTIME_TYPECHECKING=1 uv run pytest --cov\n</code></pre> <p>!!! tip \"Automatically Enabled\"       Runtime type checking is automatically enabled in these scenarios:</p> <pre><code>  - **Hatch development environment** (`hatch shell dev`)\n  - **VS Code debugging** (when using the debugger)\n  - **VS Code testing** (when running tests through VS Code's testing interface)\n\n  No manual setup needed in these environments!\n</code></pre> <p>For more details on runtime type checking, see the Development Guidelines.</p>"},{"location":"contributing/#step-6-documentation-updates-if-needed","title":"Step 6: Documentation Updates (If Needed) \ud83d\udcd6","text":"<ul> <li>If you add a new feature, update the documentation accordingly.</li> <li>We use MKDocs for documentation:</li> <li>Modify or create markdown files in the <code>docs/</code> folder.</li> <li> <p>Preview your changes by running:</p> <pre><code>mkdocs serve\nuv run mkdocs serve #If using uv\n</code></pre> </li> <li> <p>Open <code>http://127.0.0.1:8000</code> in your browser to verify documentation updates.</p> </li> </ul>"},{"location":"contributing/#step-7-push-changes-and-open-a-pull-request-pr","title":"Step 7: Push Changes and Open a Pull Request (PR) \ud83d\ude80","text":"<ol> <li>Push your changes to your fork:</li> </ol> <pre><code>git push origin feature-name\n</code></pre> <ol> <li>Open a pull request (PR):</li> <li>Follow GitHub\u2019s PR guide.</li> <li>Link the issue you are solving in the PR description.</li> </ol> <p>Thank you again for your contribution! \ud83c\udf89</p>"},{"location":"roadmap/","title":"Roadmap \ud83d\uddfa\ufe0f","text":"<p>This document outlines the development roadmap for the mesa-frames project. It provides insights into our current priorities, upcoming features, and long-term vision.</p>"},{"location":"roadmap/#010-stable-release-goals","title":"0.1.0 Stable Release Goals \ud83c\udfaf","text":""},{"location":"roadmap/#1-transitioning-polars-implementation-from-eager-api-to-lazy-api","title":"1. Transitioning polars implementation from eager API to lazy API","text":"<p>One of our major priorities was to move from pandas to polars as the primary dataframe backend. This transition was motivated by performance considerations. Now we should transition to using the lazily evaluated version of polars.</p> <p>Related issues: #10: GPU integration: Dask, cuda (cudf) and RAPIDS (Polars), #89: Investigate using Ibis for the common interface library to any DF backend, #52: Use of LazyFrames for Polars implementation</p>"},{"location":"roadmap/#progress-and-next-steps","title":"Progress and Next Steps","text":"<ul> <li>We are exploring Ibis or narwhals as a common interface library that could support multiple backends (Polars, DuckDB, Spark etc.), but since most of the development is currently in polars, we will currently continue using Polars.</li> <li>We're transitioning to the lazy API, mainly in order to use GPU acceleration</li> </ul>"},{"location":"roadmap/#2-handling-concurrency-management","title":"2. Handling Concurrency Management","text":"<p>A critical aspect of agent-based models is efficiently managing concurrent agent movements, especially when multiple agents attempt to move to the same location simultaneously. We aim to implement abstractions that handle these concurrency conditions automatically.</p> <p>Related issues: #108: Adding abstraction of optimal agent movement, #48: Emulate RandomActivation with DataFrame.rolling</p>"},{"location":"roadmap/#sugarscape-example-of-concurrency-issues","title":"Sugarscape Example of Concurrency Issues","text":"<p>Testing with many potential collisions revealed a specific issue:</p> <p>Problem scenario:</p> <ul> <li>Consider two agents targeting the same cell:</li> <li>A mid-priority agent (higher in the agent order)</li> <li>A low-priority agent (lower in the agent order)</li> <li>The mid-priority agent has low preference for the cell</li> <li>The low-priority agent has high preference for the cell</li> <li>Without accounting for priority:</li> <li>The mid-priority agent's best moves kept getting \"stolen\" by higher priority agents</li> <li>This forced it to resort to lower preference target cells</li> <li>However, these lower preference cells were often already taken by lower priority agents in previous iterations</li> </ul> <p>Solution approach:</p> <ul> <li>Implement a \"priority\" count to ensure that each action is \"legal\"</li> <li>This prevents race conditions but requires recomputing the priority at each iteration</li> <li>Current implementation may be slower than Numba due to this overhead</li> <li>After the Ibis refactoring, we can investigate if lazy evaluation can help mitigate this performance issue</li> </ul> <p>The Sugarscape example demonstrates the need for this abstraction, as multiple agents often attempt to move to the same cell simultaneously. By generalizing this functionality, we can eliminate the need for users to implement complex conflict resolution logic repeatedly.</p>"},{"location":"roadmap/#progress-and-next-steps_1","title":"Progress and Next Steps","text":"<ul> <li>Create utility functions in <code>DiscreteSpace</code> and <code>AgentSetRegistry</code> to move agents optimally based on specified attributes</li> <li>Provide built-in resolution strategies for common concurrency scenarios</li> <li>Ensure the implementation works efficiently with the vectorized approach of mesa-frames</li> </ul>"},{"location":"roadmap/#additional-010-goals","title":"Additional 0.1.0 Goals","text":"<ul> <li>Complete core API stabilization</li> <li>Completely mirror mesa's functionality</li> <li>Improve documentation and examples</li> <li>Address outstanding bugs and performance issues</li> </ul>"},{"location":"roadmap/#beyond-010","title":"Beyond 0.1.0","text":"<p>Future roadmap items will be added as the project evolves and new priorities emerge.</p> <p>We welcome community feedback on our roadmap! Please open an issue if you have suggestions or would like to contribute to any of these initiatives.</p>"},{"location":"development/","title":"Development Guidelines","text":""},{"location":"development/#runtime-type-checking","title":"Runtime Type Checking \ud83d\udd0d","text":"<p>mesa-frames includes optional runtime type checking using beartype for development and debugging purposes. This feature helps catch type-related errors early during development and testing.</p> <p>Automatically Enabled</p> <p>Runtime type checking is automatically enabled in the following scenarios:</p> <ul> <li>Hatch development environment (<code>hatch shell dev</code>) \u2014 via <code>pyproject.toml</code> configuration</li> <li>VS Code debugging \u2014 when using the debugger (<code>F5</code> or \"Python Debugger: Current File\")</li> <li>VS Code testing \u2014 when running tests through VS Code's testing interface</li> </ul> <p>No manual setup required in these environments!</p>"},{"location":"development/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"development/#option-1-hatch-development-environment-recommended","title":"Option 1: Hatch Development Environment (Recommended)","text":"<p>The easiest way to enable runtime type checking is to use Hatch's development environment:</p> <pre><code># Enter the development environment (auto-enables runtime type checking)\nhatch shell dev\n\n# Verify it's enabled\npython -c \"import os; print('Runtime type checking:', os.getenv('MESA_FRAMES_RUNTIME_TYPECHECKING'))\"\n# \u2192 Runtime type checking: true\n</code></pre>"},{"location":"development/#option-2-manual-environment-variable","title":"Option 2: Manual Environment Variable","text":"<p>For other development setups, you can manually enable runtime type checking:</p> <p>Runtime type checking can be enabled by setting the <code>MESA_FRAMES_RUNTIME_TYPECHECKING</code> environment variable:</p> <pre><code>export MESA_FRAMES_RUNTIME_TYPECHECKING=1\n# or\nexport MESA_FRAMES_RUNTIME_TYPECHECKING=true\n# or\nexport MESA_FRAMES_RUNTIME_TYPECHECKING=yes\n</code></pre>"},{"location":"development/#usage-examples","title":"Usage Examples","text":"<p>Automatic Activation</p> <p>If you're using Hatch dev environment, VS Code debugging, or VS Code testing, runtime type checking is already enabled automatically. The examples below are for manual activation in other scenarios.</p>"},{"location":"development/#for-development-and-testing","title":"For Development and Testing","text":"<pre><code># Enable runtime type checking for testing\nMESA_FRAMES_RUNTIME_TYPECHECKING=1 uv run pytest\n\n# Enable runtime type checking for running scripts\nMESA_FRAMES_RUNTIME_TYPECHECKING=1 uv run python your_script.py\n</code></pre>"},{"location":"development/#in-your-ide-or-development-environment","title":"In Your IDE or Development Environment","text":"<p>VS Code (Already Configured):</p> <ul> <li>Debugging: Runtime type checking is automatically enabled when using VS Code's debugger</li> <li>Testing: Automatically enabled when running tests through VS Code's testing interface</li> <li> <p>Manual override: You can also add it manually in <code>.vscode/settings.json</code>:</p> <pre><code>{\n    \"python.env\": {\n        \"MESA_FRAMES_RUNTIME_TYPECHECKING\": \"1\"\n    }\n}\n</code></pre> </li> </ul> <p>PyCharm: In your run configuration, add the environment variable:</p> <pre><code>MESA_FRAMES_RUNTIME_TYPECHECKING=1\n</code></pre>"},{"location":"development/#how-it-works","title":"How It Works","text":"<p>When enabled, the runtime type checking system:</p> <ol> <li>Automatically instruments all mesa-frames packages with beartype decorators</li> <li>Validates function arguments and return values at runtime</li> <li>Provides detailed error messages when type mismatches occur</li> <li>Helps catch type-related bugs during development</li> </ol>"},{"location":"development/#requirements","title":"Requirements","text":"<p>Runtime type checking requires the optional <code>beartype</code> dependency:</p> <pre><code># Install beartype for runtime type checking\nuv add beartype\n# or\npip install beartype\n</code></pre> <p>Optional Dependency</p> <p>If <code>beartype</code> is not installed and runtime type checking is enabled, mesa-frames will issue a warning and continue without type checking.</p>"},{"location":"development/#performance-considerations","title":"Performance Considerations","text":"<p>Development Only</p> <p>Runtime type checking adds significant overhead and should only be used during development and testing. Do not enable it in production environments.</p> <p>The overhead includes:</p> <ul> <li>Function call interception and validation</li> <li>Type checking computations at runtime</li> <li>Memory usage for type checking infrastructure</li> </ul>"},{"location":"development/#when-to-use-runtime-type-checking","title":"When to Use Runtime Type Checking","text":"<p>\u2705 Automatically enabled (recommended):</p> <ul> <li>Hatch development environment (<code>hatch shell dev</code>)</li> <li>VS Code debugging sessions</li> <li>VS Code test execution</li> <li>Contributing to mesa-frames development</li> </ul> <p>\u2705 Manual activation (when needed):</p> <ul> <li>Development and debugging in other IDEs</li> <li>Writing new features outside VS Code</li> <li>Running unit tests from command line</li> <li>Troubleshooting type-related issues</li> </ul> <p>\u274c Not recommended for:</p> <ul> <li>Production deployments</li> <li>Performance benchmarking</li> <li>Large-scale simulations</li> <li>Final model runs</li> </ul>"},{"location":"development/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues with runtime type checking:</p> <ol> <li>Check beartype installation:</li> </ol> <pre><code>uv run python -c \"import beartype; print(beartype.__version__)\"\n</code></pre> <ol> <li>Verify environment variable:</li> </ol> <pre><code>echo $MESA_FRAMES_RUNTIME_TYPECHECKING\n</code></pre> <ol> <li>For automatic configurations:</li> <li>Hatch dev: Ensure you're in the dev environment (<code>hatch shell dev</code>)</li> <li>VS Code debugging: Check that the debugger configuration in <code>.vscode/launch.json</code> includes the environment variable</li> <li> <p>VS Code testing: Verify that <code>.env.test</code> file exists and contains <code>MESA_FRAMES_RUNTIME_TYPECHECKING=true</code></p> </li> <li> <p>Check for warnings in your application logs</p> </li> <li> <p>Disable temporarily if needed:</p> </li> </ol> <pre><code>unset MESA_FRAMES_RUNTIME_TYPECHECKING\n</code></pre> <p>Pro Tip</p> <p>Runtime type checking is particularly useful when developing custom AgentSet implementations or working with complex DataFrame operations where type safety is crucial.</p>"},{"location":"user-guide/0_getting-started/","title":"Getting Started \ud83d\ude80","text":""},{"location":"user-guide/0_getting-started/#main-concepts","title":"Main Concepts \ud83e\udde0","text":""},{"location":"user-guide/0_getting-started/#dataframe-based-object-oriented-framework","title":"DataFrame-Based Object-Oriented Framework \ud83d\udcca","text":"<p>Unlike traditional mesa models where each agent is an individual Python object, mesa-frames stores all agents of a particular type in a single DataFrame. We operate only at the AgentSet level.</p> <p>This approach allows for:</p> <ul> <li>Efficient memory usage</li> <li>Improved performance through vectorized operations on agent attributes (This is what makes <code>mesa-frames</code> fast)</li> </ul> <p>Objects can be easily subclassed to respect mesa's object-oriented philosophy.</p>"},{"location":"user-guide/0_getting-started/#vectorized-operations","title":"Vectorized Operations \u26a1","text":"<p>mesa-frames leverages the power of vectorized operations provided by DataFrame libraries:</p> <ul> <li>Operations are performed on entire columns of data at once</li> <li>This approach is significantly faster than iterating over individual agents</li> <li>Complex behaviors can be expressed in fewer lines of code</li> </ul> <p>You should never use loops to iterate through your agents. Instead, use vectorized operations and implemented methods. If you need to loop, loop through vectorized operations (see the advanced tutorial SugarScape IG for more information).</p> <p>It's important to note that in traditional <code>mesa</code> models, the order in which agents are activated can significantly impact the results of the model (see Comer, 2014). <code>mesa-frames</code>, by default, doesn't have this issue as all agents are processed simultaneously. However, this comes with the trade-off of needing to carefully implement conflict resolution mechanisms when sequential processing is required. We'll discuss how to handle these situations later in this guide.</p> <p>Check out these resources to understand vectorization and why it speeds up the code:</p> <ul> <li>What is vectorization?</li> <li>Vectorization Explained, Step by Step</li> </ul> <p>Here's a comparison between mesa-frames and mesa:</p> mesa-framesmesa <pre><code>class MoneyAgents(AgentSet):\n    # initialization...\n    def give_money(self):\n        # Active agents are changed to wealthy agents\n        self.select(self.wealth &gt; 0)\n\n        # Receiving agents are sampled (only native expressions currently supported)\n        other_agents = self.sets.sample(\n            n=len(self.active_agents), with_replacement=True\n        )\n\n        # Wealth of wealthy is decreased by 1\n        self[\"active\", \"wealth\"] -= 1\n\n        # Compute the income of the other agents (only native expressions currently supported)\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n\n        # Add the income to the other agents\n        self[new_wealth, \"wealth\"] += new_wealth[\"len\"]\n</code></pre> <pre><code>class MoneyAgent(mesa.Agent):\n    # initialization...\n    def give_money(self):\n        # Verify agent has some wealth\n        if self.wealth &gt; 0:\n            other_agent = self.random.choice(self.model.sets)\n            if other_agent is not None:\n                other_agent.wealth += 1\n                self.wealth -= 1\n</code></pre> <p>As you can see, while in mesa you should iterate through all the agents' steps in the model class, here you execute the method once for all agents.</p>"},{"location":"user-guide/0_getting-started/#coming-from-mesa","title":"Coming from mesa \ud83d\udd00","text":"<p>If you're familiar with mesa, this guide will help you understand the key differences in code structure between mesa and mesa-frames.</p>"},{"location":"user-guide/0_getting-started/#agent-representation","title":"Agent Representation \ud83d\udc65","text":"<ul> <li>mesa: Each agent is an individual object instance. Methods are defined for individual agents and called on each agent.</li> <li>mesa-frames: Agents are rows in a DataFrame, grouped into AgentSets. Methods are defined for AgentSets and operate on all agents simultaneously.</li> </ul> mesa-framesmesa <pre><code>class MoneyAgents(AgentSet):\n    def __init__(self, n, model):\n        super().__init__(model)\n        self += pl.DataFrame({\n            \"wealth\": pl.ones(n)\n            })\n    def step(self):\n        givers = self.wealth &gt; 0\n        receivers = self.sets.sample(n=len(self.active_agents))\n        self[givers, \"wealth\"] -= 1\n        new_wealth = receivers.groupby(\"unique_id\").count()\n        self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"count\"]\n</code></pre> <pre><code>class MoneyAgent(Agent):\n    def __init__(self, unique_id, model):\n        super().__init__(unique_id, model)\n        self.wealth = 1\n\n    def step(self):\n        if self.wealth &gt; 0:\n            other_agent = self.random.choice(self.model.schedule.agents)\n            other_agent.wealth += 1\n            self.wealth -= 1\n</code></pre>"},{"location":"user-guide/0_getting-started/#model-structure","title":"Model Structure \ud83c\udfd7\ufe0f","text":"<ul> <li>mesa: Models manage individual agents and use a scheduler.</li> <li>mesa-frames: Models manage AgentSets and directly control the simulation flow.</li> </ul> mesa-framesmesa <pre><code>class MoneyModel(Model):\n    def __init__(self, N):\n        super().__init__()\n        self.sets += MoneyAgents(N, self)\n\n    def step(self):\n        self.sets.do(\"step\")\n</code></pre> <pre><code>class MoneyModel(Model):\n    def __init__(self, N):\n        self.num_agents = N\n        self.schedule = RandomActivation(self)\n        for i in range(self.num_agents):\n            a = MoneyAgent(i, self)\n            self.schedule.add(a)\n\n    def step(self):\n        self.schedule.step()\n</code></pre>"},{"location":"user-guide/0_getting-started/#transition-tips","title":"Transition Tips \ud83d\udca1","text":"<ol> <li>Think in Sets \ud83c\udfad: Instead of individual agents, think about operations on groups of agents.</li> <li>Leverage DataFrame Operations \ud83d\udee0\ufe0f: Familiarize yourself with Polars operations for efficient agent manipulation.</li> <li>Vectorize Logic \ud83d\ude85: Convert loops and conditionals to vectorized operations where possible.</li> <li>Use AgentSets \ud83d\udce6: Group similar agents into AgentSets instead of creating many individual agent classes.</li> </ol>"},{"location":"user-guide/0_getting-started/#handling-race-conditions","title":"Handling Race Conditions \ud83c\udfc1","text":"<p>When simultaneous activation is not possible, you need to handle race conditions carefully. There are two main approaches:</p> <ol> <li> <p>Custom UDF with Numba \ud83d\udd27: Use a custom User Defined Function (UDF) with Numba for efficient sequential processing.</p> </li> <li> <p>Polars UDF Guide</p> </li> <li> <p>Looping Mechanism \ud83d\udd01: Implement a looping mechanism on vectorized operations.</p> </li> </ol> <p>For a more detailed implementation of handling race conditions, please refer to the <code>examples/sugarscape-ig</code> in the mesa-frames repository. This example demonstrates how to implement the Sugarscape model with instantaneous growback, which requires careful handling of sequential agent actions.</p>"},{"location":"user-guide/1_classes/","title":"Classes \ud83d\udcda","text":""},{"location":"user-guide/1_classes/#agentset","title":"AgentSet \ud83d\udc65","text":"<p>To create your own AgentSet class, you need to subclass the AgentSet class and make sure to call <code>super().__init__(model)</code>.</p> <p>Typically, the next step would be to populate the class with your agents. To do that, you need to add a DataFrame to the AgentSet. You can do <code>self += agents</code> or <code>self.add(agents)</code>, where <code>agents</code> is a DataFrame or something that could be passed to a DataFrame constructor, like a dictionary or lists of lists. You need to make sure your DataFrame doesn't have a 'unique_id' column because IDs are generated automatically, otherwise you will get an error raised. In the DataFrame, you should also put any attribute of the agent you are using.</p> <p>How can you choose which agents should be in the same AgentSet? The idea is that you should minimize the missing values in the DataFrame (so they should have similar/same attributes) and mostly everybody should do the same actions.</p> <p>Example:</p> <pre><code>class MoneyAgents(AgentSet):\n    def __init__(self, n: int, model: Model):\n        super().__init__(model)\n        self.initial_wealth = pl.ones(n)\n        self += pl.DataFrame({\n            \"wealth\": self.initial_wealth\n        })\n\n    def step(self):\n        self[\"wealth\"] = self[\"wealth\"] + self.random.integers(n)\n</code></pre> <p>You can access the underlying DataFrame where agents are stored with <code>self.df</code>. This allows you to use DataFrame methods like <code>self.df.sample</code> or <code>self.df.group_by(\"wealth\")</code> and more.</p>"},{"location":"user-guide/1_classes/#model","title":"Model \ud83c\udfd7\ufe0f","text":"<p>To add your AgentSet to your Model, you should also add it to the sets with <code>+=</code> or <code>add</code>.</p> <p>NOTE: Model.sets are stored in a class which is entirely similar to AgentSet called AgentSetRegistry. The API of the two are the same. If you try accessing AgentSetRegistry.df, you will get a dictionary of <code>[AgentSet, DataFrame]</code>.</p> <p>Example:</p> <pre><code>class EcosystemModel(Model):\n    def __init__(self, n_prey, n_predators):\n        super().__init__()\n        self.sets += Preys(n_prey, self)\n        self.sets += Predators(n_predators, self)\n\n    def step(self):\n        self.sets.do(\"move\")\n        self.sets.do(\"hunt\")\n        self.prey.do(\"reproduce\")\n</code></pre>"},{"location":"user-guide/1_classes/#space-grid","title":"Space: Grid \ud83c\udf10","text":"<p>mesa-frames provides efficient implementations of spatial environments:</p> <ul> <li>Spatial operations (like moving agents) are vectorized for performance</li> </ul> <p>Example:</p> <pre><code>class GridWorld(Model):\n    def __init__(self, width, height):\n        super().__init__()\n        self.space = Grid(self, (width, height))\n        self.sets += AgentSet(100, self)\n        self.space.place_to_empty(self.sets)\n</code></pre> <p>A continuous GeoSpace, NetworkSpace, and a collection to have multiple spaces in the models are in the works! \ud83d\udea7</p>"},{"location":"user-guide/1_classes/#datacollector","title":"DataCollector \ud83d\uddc2\ufe0f","text":"<p><code>DataCollector</code> records model- and agent-level data during simulation. You configure what to collect, how to store it, and when to trigger collection.</p> <p>Example:</p> <pre><code>class ExampleModel(Model):\n    def __init__(self):\n        super().__init__()\n        self.sets = MoneyAgent(self)\n        self.datacollector = DataCollector(\n            model=self,\n            model_reporters={\"total_wealth\": lambda m: lambda m: list(m.sets.df.values())[0][\"wealth\"].sum()},\n            agent_reporters={\"wealth\": \"wealth\"},\n            storage=\"csv\",\n            storage_uri=\"./data\",\n            trigger=lambda m: m.schedule.steps % 2 == 0\n        )\n\n    def step(self):\n        self.sets.step()\n        self.datacollector.conditional_collect()\n        self.datacollector.flush()\n</code></pre>"},{"location":"user-guide/2_introductory-tutorial/","title":"Introductory Tutorial","text":"In\u00a0[1]: Copied! <pre># !pip install git+https://github.com/projectmesa/mesa-frames mesa\n</pre> # !pip install git+https://github.com/projectmesa/mesa-frames mesa In\u00a0[2]: Copied! <pre>from mesa_frames import Model, AgentSet, DataCollector\n\n\nclass MoneyModel(Model):\n    def __init__(self, N: int, agents_cls):\n        super().__init__()\n        self.n_agents = N\n        self.sets += agents_cls(N, self)\n        self.datacollector = DataCollector(\n            model=self,\n            model_reporters={\"total_wealth\": lambda m: m.agents[\"wealth\"].sum()},\n            agent_reporters={\"wealth\": \"wealth\"},\n            storage=\"csv\",\n            storage_uri=\"./data\",\n            trigger=lambda m: m.schedule.steps % 2 == 0,\n        )\n\n    def step(self):\n        # Executes the step method for every agentset in self.sets\n        self.sets.do(\"step\")\n\n    def run_model(self, n):\n        for _ in range(n):\n            self.step()\n            self.datacollector.conditional_collect\n        self.datacollector.flush()\n</pre> from mesa_frames import Model, AgentSet, DataCollector   class MoneyModel(Model):     def __init__(self, N: int, agents_cls):         super().__init__()         self.n_agents = N         self.sets += agents_cls(N, self)         self.datacollector = DataCollector(             model=self,             model_reporters={\"total_wealth\": lambda m: m.agents[\"wealth\"].sum()},             agent_reporters={\"wealth\": \"wealth\"},             storage=\"csv\",             storage_uri=\"./data\",             trigger=lambda m: m.schedule.steps % 2 == 0,         )      def step(self):         # Executes the step method for every agentset in self.sets         self.sets.do(\"step\")      def run_model(self, n):         for _ in range(n):             self.step()             self.datacollector.conditional_collect         self.datacollector.flush() In\u00a0[3]: Copied! <pre>import polars as pl\n\n\nclass MoneyAgents(AgentSet):\n    def __init__(self, n: int, model: Model):\n        super().__init__(model)\n        self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})\n\n    def step(self) -&gt; None:\n        self.do(\"give_money\")\n\n    def give_money(self):\n        self.select(self.wealth &gt; 0)\n        other_agents = self.df.sample(n=len(self.active_agents), with_replacement=True)\n        self[\"active\", \"wealth\"] -= 1\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n        self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"len\"]\n</pre> import polars as pl   class MoneyAgents(AgentSet):     def __init__(self, n: int, model: Model):         super().__init__(model)         self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})      def step(self) -&gt; None:         self.do(\"give_money\")      def give_money(self):         self.select(self.wealth &gt; 0)         other_agents = self.df.sample(n=len(self.active_agents), with_replacement=True)         self[\"active\", \"wealth\"] -= 1         new_wealth = other_agents.group_by(\"unique_id\").len()         self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"len\"] In\u00a0[4]: Copied! <pre># Create and run the model\nmodel = MoneyModel(1000, MoneyAgents)\nmodel.run_model(100)\n\nwealth_dist = list(model.sets.df.values())[0]\n\n# Print the final wealth distribution\nprint(wealth_dist.select(pl.col(\"wealth\")).describe())\n</pre> # Create and run the model model = MoneyModel(1000, MoneyAgents) model.run_model(100)  wealth_dist = list(model.sets.df.values())[0]  # Print the final wealth distribution print(wealth_dist.select(pl.col(\"wealth\")).describe()) <pre>shape: (9, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 statistic  \u2506 wealth  \u2502\n\u2502 ---        \u2506 ---     \u2502\n\u2502 str        \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 count      \u2506 1000.0  \u2502\n\u2502 null_count \u2506 0.0     \u2502\n\u2502 mean       \u2506 1.0     \u2502\n\u2502 std        \u2506 1.15989 \u2502\n\u2502 min        \u2506 0.0     \u2502\n\u2502 25%        \u2506 0.0     \u2502\n\u2502 50%        \u2506 1.0     \u2502\n\u2502 75%        \u2506 2.0     \u2502\n\u2502 max        \u2506 7.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> <p>This output shows the statistical summary of the wealth distribution after 100 steps of the simulation with 1000 agents.</p> In\u00a0[5]: Copied! <pre>class MoneyAgentsConcise(AgentSet):\n    def __init__(self, n: int, model: Model):\n        super().__init__(model)\n        ## Adding the agents to the agent set\n        # 1. Changing the df attribute directly (not recommended, if other agents were added before, they will be lost)\n        \"\"\"self.df = pl.DataFrame(\n            {\"wealth\": pl.ones(n, eager=True)}\n        )\"\"\"\n        # 2. Adding the dataframe with add\n        \"\"\"self.add(\n            pl.DataFrame(\n                {\n                    \"wealth\": pl.ones(n, eager=True),\n                }\n            )\n        )\"\"\"\n        # 3. Adding the dataframe with __iadd__\n        self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})\n\n    def step(self) -&gt; None:\n        # The give_money method is called\n        # self.give_money()\n        self.do(\"give_money\")\n\n    def give_money(self):\n        ## Active agents are changed to wealthy agents\n        # 1. Using the __getitem__ method\n        # self.select(self[\"wealth\"] &gt; 0)\n        # 2. Using the fallback __getattr__ method\n        self.select(self.wealth &gt; 0)\n\n        # Receiving agents are sampled (only native expressions currently supported)\n        other_agents = self.df.sample(n=len(self.active_agents), with_replacement=True)\n\n        # Wealth of wealthy is decreased by 1\n        # 1. Using the __setitem__ method with self.active_agents mask\n        # self[self.active_agents, \"wealth\"] -= 1\n        # 2. Using the __setitem__ method with \"active\" mask\n        self[\"active\", \"wealth\"] -= 1\n\n        # Compute the income of the other agents (only native expressions currently supported)\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n\n        # Add the income to the other agents\n        # 1. Using the set method\n        \"\"\"self.set(\n            attr_names=\"wealth\",\n            values=pl.col(\"wealth\") + new_wealth[\"len\"],\n            mask=new_wealth,\n        )\"\"\"\n\n        # 2. Using the __setitem__ method\n        self[new_wealth, \"wealth\"] += new_wealth[\"len\"]\n\n\nclass MoneyAgentsNative(AgentSet):\n    def __init__(self, n: int, model: Model):\n        super().__init__(model)\n        self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})\n\n    def step(self) -&gt; None:\n        self.do(\"give_money\")\n\n    def give_money(self):\n        ## Active agents are changed to wealthy agents\n        self.select(pl.col(\"wealth\") &gt; 0)\n\n        other_agents = self.df.sample(n=len(self.active_agents), with_replacement=True)\n\n        # Wealth of wealthy is decreased by 1\n        self.df = self.df.with_columns(\n            wealth=pl.when(\n                pl.col(\"unique_id\").is_in(self.active_agents[\"unique_id\"].implode())\n            )\n            .then(pl.col(\"wealth\") - 1)\n            .otherwise(pl.col(\"wealth\"))\n        )\n\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n\n        # Add the income to the other agents\n        self.df = (\n            self.df.join(new_wealth, on=\"unique_id\", how=\"left\")\n            .fill_null(0)\n            .with_columns(wealth=pl.col(\"wealth\") + pl.col(\"len\"))\n            .drop(\"len\")\n        )\n</pre> class MoneyAgentsConcise(AgentSet):     def __init__(self, n: int, model: Model):         super().__init__(model)         ## Adding the agents to the agent set         # 1. Changing the df attribute directly (not recommended, if other agents were added before, they will be lost)         \"\"\"self.df = pl.DataFrame(             {\"wealth\": pl.ones(n, eager=True)}         )\"\"\"         # 2. Adding the dataframe with add         \"\"\"self.add(             pl.DataFrame(                 {                     \"wealth\": pl.ones(n, eager=True),                 }             )         )\"\"\"         # 3. Adding the dataframe with __iadd__         self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})      def step(self) -&gt; None:         # The give_money method is called         # self.give_money()         self.do(\"give_money\")      def give_money(self):         ## Active agents are changed to wealthy agents         # 1. Using the __getitem__ method         # self.select(self[\"wealth\"] &gt; 0)         # 2. Using the fallback __getattr__ method         self.select(self.wealth &gt; 0)          # Receiving agents are sampled (only native expressions currently supported)         other_agents = self.df.sample(n=len(self.active_agents), with_replacement=True)          # Wealth of wealthy is decreased by 1         # 1. Using the __setitem__ method with self.active_agents mask         # self[self.active_agents, \"wealth\"] -= 1         # 2. Using the __setitem__ method with \"active\" mask         self[\"active\", \"wealth\"] -= 1          # Compute the income of the other agents (only native expressions currently supported)         new_wealth = other_agents.group_by(\"unique_id\").len()          # Add the income to the other agents         # 1. Using the set method         \"\"\"self.set(             attr_names=\"wealth\",             values=pl.col(\"wealth\") + new_wealth[\"len\"],             mask=new_wealth,         )\"\"\"          # 2. Using the __setitem__ method         self[new_wealth, \"wealth\"] += new_wealth[\"len\"]   class MoneyAgentsNative(AgentSet):     def __init__(self, n: int, model: Model):         super().__init__(model)         self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})      def step(self) -&gt; None:         self.do(\"give_money\")      def give_money(self):         ## Active agents are changed to wealthy agents         self.select(pl.col(\"wealth\") &gt; 0)          other_agents = self.df.sample(n=len(self.active_agents), with_replacement=True)          # Wealth of wealthy is decreased by 1         self.df = self.df.with_columns(             wealth=pl.when(                 pl.col(\"unique_id\").is_in(self.active_agents[\"unique_id\"].implode())             )             .then(pl.col(\"wealth\") - 1)             .otherwise(pl.col(\"wealth\"))         )          new_wealth = other_agents.group_by(\"unique_id\").len()          # Add the income to the other agents         self.df = (             self.df.join(new_wealth, on=\"unique_id\", how=\"left\")             .fill_null(0)             .with_columns(wealth=pl.col(\"wealth\") + pl.col(\"len\"))             .drop(\"len\")         ) <p>Add Mesa implementation of MoneyAgent and MoneyModel classes to test Mesa performance</p> In\u00a0[6]: Copied! <pre>import mesa\n\n\nclass MesaMoneyAgent(mesa.Agent):\n    \"\"\"An agent with fixed initial wealth.\"\"\"\n\n    def __init__(self, model):\n        # Pass the parameters to the parent class.\n        super().__init__(model)\n\n        # Create the agent's variable and set the initial values.\n        self.wealth = 1\n\n    def step(self):\n        # Verify agent has some wealth\n        if self.wealth &gt; 0:\n            other_agent: MesaMoneyAgent = self.model.random.choice(self.model.agents)\n            if other_agent is not None:\n                other_agent.wealth += 1\n                self.wealth -= 1\n\n\nclass MesaMoneyModel(mesa.Model):\n    \"\"\"A model with some number of agents.\"\"\"\n\n    def __init__(self, N: int):\n        super().__init__()\n        self.num_agents = N\n        for _ in range(N):\n            self.agents.add(MesaMoneyAgent(self))\n\n    def step(self):\n        \"\"\"Advance the model by one step.\"\"\"\n        self.agents.shuffle_do(\"step\")\n\n    def run_model(self, n_steps) -&gt; None:\n        for _ in range(n_steps):\n            self.step()\n</pre> import mesa   class MesaMoneyAgent(mesa.Agent):     \"\"\"An agent with fixed initial wealth.\"\"\"      def __init__(self, model):         # Pass the parameters to the parent class.         super().__init__(model)          # Create the agent's variable and set the initial values.         self.wealth = 1      def step(self):         # Verify agent has some wealth         if self.wealth &gt; 0:             other_agent: MesaMoneyAgent = self.model.random.choice(self.model.agents)             if other_agent is not None:                 other_agent.wealth += 1                 self.wealth -= 1   class MesaMoneyModel(mesa.Model):     \"\"\"A model with some number of agents.\"\"\"      def __init__(self, N: int):         super().__init__()         self.num_agents = N         for _ in range(N):             self.agents.add(MesaMoneyAgent(self))      def step(self):         \"\"\"Advance the model by one step.\"\"\"         self.agents.shuffle_do(\"step\")      def run_model(self, n_steps) -&gt; None:         for _ in range(n_steps):             self.step() <pre>/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[7]: Copied! <pre>import time\n\n\ndef run_simulation(model: MesaMoneyModel | MoneyModel, n_steps: int):\n    start_time = time.time()\n    model.run_model(n_steps)\n    end_time = time.time()\n    return end_time - start_time\n\n\n# Compare mesa and mesa-frames implementations\nn_agents_list = [10**2, 10**3 + 1, 2 * 10**3]\nn_steps = 100\nprint(\"Execution times:\")\nfor implementation in [\n    \"mesa\",\n    \"mesa-frames (pl concise)\",\n    \"mesa-frames (pl native)\",\n]:\n    print(f\"---------------\\n{implementation}:\")\n    for n_agents in n_agents_list:\n        if implementation == \"mesa\":\n            ntime = run_simulation(MesaMoneyModel(n_agents), n_steps)\n        elif implementation == \"mesa-frames (pl concise)\":\n            ntime = run_simulation(MoneyModel(n_agents, MoneyAgentsConcise), n_steps)\n        elif implementation == \"mesa-frames (pl native)\":\n            ntime = run_simulation(MoneyModel(n_agents, MoneyAgentsNative), n_steps)\n\n        print(f\"  Number of agents: {n_agents}, Time: {ntime:.2f} seconds\")\n    print(\"---------------\")\n</pre> import time   def run_simulation(model: MesaMoneyModel | MoneyModel, n_steps: int):     start_time = time.time()     model.run_model(n_steps)     end_time = time.time()     return end_time - start_time   # Compare mesa and mesa-frames implementations n_agents_list = [10**2, 10**3 + 1, 2 * 10**3] n_steps = 100 print(\"Execution times:\") for implementation in [     \"mesa\",     \"mesa-frames (pl concise)\",     \"mesa-frames (pl native)\", ]:     print(f\"---------------\\n{implementation}:\")     for n_agents in n_agents_list:         if implementation == \"mesa\":             ntime = run_simulation(MesaMoneyModel(n_agents), n_steps)         elif implementation == \"mesa-frames (pl concise)\":             ntime = run_simulation(MoneyModel(n_agents, MoneyAgentsConcise), n_steps)         elif implementation == \"mesa-frames (pl native)\":             ntime = run_simulation(MoneyModel(n_agents, MoneyAgentsNative), n_steps)          print(f\"  Number of agents: {n_agents}, Time: {ntime:.2f} seconds\")     print(\"---------------\") <pre>Execution times:\n---------------\nmesa:\n  Number of agents: 100, Time: 0.06 seconds\n</pre> <pre>  Number of agents: 1001, Time: 3.67 seconds\n</pre> <pre>  Number of agents: 2000, Time: 14.02 seconds\n---------------\n---------------\nmesa-frames (pl concise):\n</pre> <pre>  Number of agents: 100, Time: 0.33 seconds\n</pre> <pre>  Number of agents: 1001, Time: 0.35 seconds\n</pre> <pre>  Number of agents: 2000, Time: 0.38 seconds\n---------------\n---------------\nmesa-frames (pl native):\n  Number of agents: 100, Time: 0.14 seconds\n</pre> <pre>  Number of agents: 1001, Time: 0.15 seconds\n  Number of agents: 2000, Time: 0.16 seconds\n---------------\n</pre>"},{"location":"user-guide/2_introductory-tutorial/#installation-if-running-in-colab","title":"Installation (if running in Colab)\u00b6","text":"<p>Run the following cell to install <code>mesa-frames</code> if you are using Google Colab.</p>"},{"location":"user-guide/2_introductory-tutorial/#introductory-tutorial-boltzmann-wealth-model-with-mesa-frames","title":"Introductory Tutorial: Boltzmann Wealth Model with mesa-frames \ud83d\udcb0\ud83d\ude80\u00b6","text":"<p>In this tutorial, we'll implement the Boltzmann Wealth Model using mesa-frames. This model simulates the distribution of wealth among agents, where agents randomly give money to each other.</p>"},{"location":"user-guide/2_introductory-tutorial/#setting-up-the-model","title":"Setting Up the Model \ud83c\udfd7\ufe0f\u00b6","text":"<p>First, let's import the necessary modules and set up our model class:</p>"},{"location":"user-guide/2_introductory-tutorial/#implementing-the-agentset","title":"Implementing the AgentSet \ud83d\udc65\u00b6","text":"<p>Now, let's implement our <code>MoneyAgents</code> using polars backends.</p>"},{"location":"user-guide/2_introductory-tutorial/#running-the-model","title":"Running the Model \u25b6\ufe0f\u00b6","text":"<p>Now that we have our model and agent set defined, let's run a simulation:</p>"},{"location":"user-guide/2_introductory-tutorial/#performance-comparison","title":"Performance Comparison \ud83c\udfce\ufe0f\ud83d\udca8\u00b6","text":"<p>One of the key advantages of mesa-frames is its performance with large numbers of agents. Let's compare the performance of mesa and polars:</p>"},{"location":"user-guide/2_introductory-tutorial/#conclusion","title":"Conclusion \ud83c\udf89\u00b6","text":"<ul> <li>All mesa-frames implementations significantly outperform the original mesa implementation. \ud83c\udfc6</li> <li>The native implementation for Polars shows better performance than their concise counterparts. \ud83d\udcaa</li> <li>The Polars native implementation shows the most impressive speed-up, ranging from 10.86x to 17.60x faster than mesa! \ud83d\ude80\ud83d\ude80\ud83d\ude80</li> <li>The performance advantage of mesa-frames becomes more pronounced as the number of agents increases. \ud83d\udcc8</li> </ul>"},{"location":"user-guide/3_advanced-tutorial/","title":"Advanced Tutorial: SugarScape with Instantaneous Growback \ud83c\udf6c\ud83d\udd04","text":"<p>Work in Progress \ud83d\udea7</p> <p>This tutorial is coming soon! \ud83d\udd1c\u2728 In the meantime, you can check out the code in the <code>examples/sugarscape-ig</code> directory of the mesa-frames repository.</p>"},{"location":"user-guide/4_datacollector/","title":"Data Collector Tutorial","text":"In\u00a0[1]: Copied! <pre># !pip install git+https://github.com/projectmesa/mesa-frames mesa\n</pre> # !pip install git+https://github.com/projectmesa/mesa-frames mesa In\u00a0[2]: Copied! <pre>from mesa_frames import Model, AgentSet, DataCollector\nimport polars as pl\n\n\nclass MoneyAgents(AgentSet):\n    def __init__(self, n: int, model: Model):\n        super().__init__(model)\n        # one column, one unit of wealth each\n        self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})\n\n    def step(self) -&gt; None:\n        self.select(self.wealth &gt; 0)\n        receivers = self.df.sample(n=len(self.active_agents), with_replacement=True)\n        self[\"active\", \"wealth\"] -= 1\n        income = receivers.group_by(\"unique_id\").len()\n        self[income[\"unique_id\"], \"wealth\"] += income[\"len\"]\n\n\nclass MoneyModel(Model):\n    def __init__(self, n: int):\n        super().__init__()\n        self.sets.add(MoneyAgents(n, self))\n        self.dc = DataCollector(\n            model=self,\n            model_reporters={\n                \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),\n                \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),\n            },\n            agent_reporters={\n                \"wealth\": \"wealth\",  # pull existing column\n            },\n            storage=\"memory\",  # we'll switch this per example\n            storage_uri=None,\n            trigger=lambda m: m.steps % 2\n            == 0,  # collect every 2 steps via conditional_collect\n            reset_memory=True,\n        )\n\n    def step(self):\n        self.sets.do(\"step\")\n\n    def run(self, steps: int, conditional: bool = True):\n        for _ in range(steps):\n            self.step()\n            self.dc.conditional_collect()  # or .collect if you want to collect every step regardless of trigger\n\n\nmodel = MoneyModel(1000)\nmodel.run(10)\nmodel.dc.data  # peek in-memory dataframes\n</pre> from mesa_frames import Model, AgentSet, DataCollector import polars as pl   class MoneyAgents(AgentSet):     def __init__(self, n: int, model: Model):         super().__init__(model)         # one column, one unit of wealth each         self += pl.DataFrame({\"wealth\": pl.ones(n, eager=True)})      def step(self) -&gt; None:         self.select(self.wealth &gt; 0)         receivers = self.df.sample(n=len(self.active_agents), with_replacement=True)         self[\"active\", \"wealth\"] -= 1         income = receivers.group_by(\"unique_id\").len()         self[income[\"unique_id\"], \"wealth\"] += income[\"len\"]   class MoneyModel(Model):     def __init__(self, n: int):         super().__init__()         self.sets.add(MoneyAgents(n, self))         self.dc = DataCollector(             model=self,             model_reporters={                 \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),                 \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),             },             agent_reporters={                 \"wealth\": \"wealth\",  # pull existing column             },             storage=\"memory\",  # we'll switch this per example             storage_uri=None,             trigger=lambda m: m.steps % 2             == 0,  # collect every 2 steps via conditional_collect             reset_memory=True,         )      def step(self):         self.sets.do(\"step\")      def run(self, steps: int, conditional: bool = True):         for _ in range(steps):             self.step()             self.dc.conditional_collect()  # or .collect if you want to collect every step regardless of trigger   model = MoneyModel(1000) model.run(10) model.dc.data  # peek in-memory dataframes Out[2]: <pre>{'model': shape: (5, 5)\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 step \u2506 seed                            \u2506 batch \u2506 total_wealth \u2506 n_agents \u2502\n \u2502 ---  \u2506 ---                             \u2506 ---   \u2506 ---          \u2506 ---      \u2502\n \u2502 i64  \u2506 str                             \u2506 i64   \u2506 f64          \u2506 i64      \u2502\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 2    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2506 1000.0       \u2506 1000     \u2502\n \u2502 4    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2506 1000.0       \u2506 1000     \u2502\n \u2502 6    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2506 1000.0       \u2506 1000     \u2502\n \u2502 8    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2506 1000.0       \u2506 1000     \u2502\n \u2502 10   \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2506 1000.0       \u2506 1000     \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518,\n 'agent': shape: (5_000, 4)\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 wealth_MoneyAgents \u2506 step \u2506 seed                            \u2506 batch \u2502\n \u2502 ---                \u2506 ---  \u2506 ---                             \u2506 ---   \u2502\n \u2502 f64                \u2506 i32  \u2506 str                             \u2506 i32   \u2502\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 1.0                \u2506 2    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 1.0                \u2506 2    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 0.0                \u2506 2    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 1.0                \u2506 2    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 2.0                \u2506 2    \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 \u2026                  \u2506 \u2026    \u2506 \u2026                               \u2506 \u2026     \u2502\n \u2502 0.0                \u2506 10   \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 0.0                \u2506 10   \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 1.0                \u2506 10   \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 1.0                \u2506 10   \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2502 1.0                \u2506 10   \u2506 261429193050881953005408348608\u2026 \u2506 0     \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518}</pre> In\u00a0[3]: Copied! <pre>import os\n\nos.makedirs(\"./data_csv\", exist_ok=True)\nmodel_csv = MoneyModel(1000)\nmodel_csv.dc = DataCollector(\n    model=model_csv,\n    model_reporters={\n        \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),\n        \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),\n    },\n    agent_reporters={\n        \"wealth\": \"wealth\",\n    },\n    storage=\"csv\",  # saving as csv\n    storage_uri=\"./data_csv\",\n    trigger=lambda m: m._steps % 2 == 0,\n    reset_memory=True,\n)\nmodel_csv.run(10)\nmodel_csv.dc.flush()\nos.listdir(\"./data_csv\")\n</pre> import os  os.makedirs(\"./data_csv\", exist_ok=True) model_csv = MoneyModel(1000) model_csv.dc = DataCollector(     model=model_csv,     model_reporters={         \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),         \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),     },     agent_reporters={         \"wealth\": \"wealth\",     },     storage=\"csv\",  # saving as csv     storage_uri=\"./data_csv\",     trigger=lambda m: m._steps % 2 == 0,     reset_memory=True, ) model_csv.run(10) model_csv.dc.flush() os.listdir(\"./data_csv\") Out[3]: <pre>[]</pre> In\u00a0[4]: Copied! <pre>os.makedirs(\"./data_parquet\", exist_ok=True)\nmodel_parq = MoneyModel(1000)\nmodel_parq.dc = DataCollector(\n    model=model_parq,\n    model_reporters={\n        \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),\n        \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),\n    },\n    agent_reporters={\n        \"wealth\": \"wealth\",\n    },\n    storage=\"parquet\",  # save as parquet\n    storage_uri=\"data_parquet\",\n    trigger=lambda m: m._steps % 2 == 0,\n    reset_memory=True,\n)\nmodel_parq.run(10)\nmodel_parq.dc.flush()\nos.listdir(\"./data_parquet\")\n</pre> os.makedirs(\"./data_parquet\", exist_ok=True) model_parq = MoneyModel(1000) model_parq.dc = DataCollector(     model=model_parq,     model_reporters={         \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),         \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),     },     agent_reporters={         \"wealth\": \"wealth\",     },     storage=\"parquet\",  # save as parquet     storage_uri=\"data_parquet\",     trigger=lambda m: m._steps % 2 == 0,     reset_memory=True, ) model_parq.run(10) model_parq.dc.flush() os.listdir(\"./data_parquet\") Out[4]: <pre>[]</pre> In\u00a0[5]: Copied! <pre>model_s3 = MoneyModel(1000)\nmodel_s3.dc = DataCollector(\n    model=model_s3,\n    model_reporters={\n        \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),\n        \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),\n    },\n    agent_reporters={\n        \"wealth\": \"wealth\",\n    },\n    storage=\"S3-csv\",  # save as csv in S3\n    storage_uri=\"s3://my-bucket/experiments/run-1\",  # change it to required path\n    trigger=lambda m: m._steps % 2 == 0,\n    reset_memory=True,\n)\nmodel_s3.run(10)\nmodel_s3.dc.flush()\n</pre> model_s3 = MoneyModel(1000) model_s3.dc = DataCollector(     model=model_s3,     model_reporters={         \"total_wealth\": lambda m: list(m.sets.df.values())[0][\"wealth\"].sum(),         \"n_agents\": lambda m: len(list(m.sets.df.values())[0]),     },     agent_reporters={         \"wealth\": \"wealth\",     },     storage=\"S3-csv\",  # save as csv in S3     storage_uri=\"s3://my-bucket/experiments/run-1\",  # change it to required path     trigger=lambda m: m._steps % 2 == 0,     reset_memory=True, ) model_s3.run(10) model_s3.dc.flush() In\u00a0[6]: Copied! <pre>DDL_MODEL = r\"\"\"\nCREATE SCHEMA IF NOT EXISTS public;\nCREATE TABLE IF NOT EXISTS public.model_data (\n  step INTEGER,\n  seed VARCHAR,\n  total_wealth BIGINT,\n  n_agents INTEGER\n);\n\"\"\"\nDDL_AGENT = r\"\"\"\nCREATE TABLE IF NOT EXISTS public.agent_data (\n  step INTEGER,\n  seed VARCHAR,\n  unique_id BIGINT,\n  wealth BIGINT\n);\n\"\"\"\nprint(DDL_MODEL)\nprint(DDL_AGENT)\n</pre> DDL_MODEL = r\"\"\" CREATE SCHEMA IF NOT EXISTS public; CREATE TABLE IF NOT EXISTS public.model_data (   step INTEGER,   seed VARCHAR,   total_wealth BIGINT,   n_agents INTEGER ); \"\"\" DDL_AGENT = r\"\"\" CREATE TABLE IF NOT EXISTS public.agent_data (   step INTEGER,   seed VARCHAR,   unique_id BIGINT,   wealth BIGINT ); \"\"\" print(DDL_MODEL) print(DDL_AGENT) <pre>\nCREATE SCHEMA IF NOT EXISTS public;\nCREATE TABLE IF NOT EXISTS public.model_data (\n  step INTEGER,\n  seed VARCHAR,\n  total_wealth BIGINT,\n  n_agents INTEGER\n);\n\n\nCREATE TABLE IF NOT EXISTS public.agent_data (\n  step INTEGER,\n  seed VARCHAR,\n  unique_id BIGINT,\n  wealth BIGINT\n);\n\n</pre> <p>After creating the tables (outside this notebook or via a DB connection cell), configure and flush:</p> In\u00a0[7]: Copied! <pre>POSTGRES_URI = \"postgresql://user:pass@localhost:5432/mydb\"\nm_pg = MoneyModel(300)\nm_pg.dc._storage = \"postgresql\"\nm_pg.dc._storage_uri = POSTGRES_URI\nm_pg.run(6)\nm_pg.dc.flush()\n</pre> POSTGRES_URI = \"postgresql://user:pass@localhost:5432/mydb\" m_pg = MoneyModel(300) m_pg.dc._storage = \"postgresql\" m_pg.dc._storage_uri = POSTGRES_URI m_pg.run(6) m_pg.dc.flush() In\u00a0[8]: Copied! <pre>m = MoneyModel(100)\nm.dc.trigger = lambda model: model._steps % 3 == 0  # every 3rd step\nm.run(10, conditional=True)\nm.dc.data[\"model\"].head()\n</pre> m = MoneyModel(100) m.dc.trigger = lambda model: model._steps % 3 == 0  # every 3rd step m.run(10, conditional=True) m.dc.data[\"model\"].head() Out[8]: shape: (5, 5)stepseedbatchtotal_wealthn_agentsi64stri64f64i642\"233450880593650249090693197166\u20260100.01004\"233450880593650249090693197166\u20260100.01006\"233450880593650249090693197166\u20260100.01008\"233450880593650249090693197166\u20260100.010010\"233450880593650249090693197166\u20260100.0100 <p>Generated on 2025-08-30.</p>"},{"location":"user-guide/4_datacollector/#data-collector-tutorial","title":"Data Collector Tutorial\u00b6","text":"<p>This notebook walks you through using the concrete <code>DataCollector</code> in <code>mesa-frames</code> to collect model- and agent-level data and write it to different storage backends: memory, CSV, Parquet, S3, and PostgreSQL.</p> <p>It also shows how to use conditional triggers and how the schema validation behaves for PostgreSQL.</p>"},{"location":"user-guide/4_datacollector/#installation-colab-or-fresh-env","title":"Installation (Colab or fresh env)\u00b6","text":"<p>Uncomment and run the next cell if you're in Colab or a clean environment.</p>"},{"location":"user-guide/4_datacollector/#minimal-example-model","title":"Minimal Example Model\u00b6","text":"<p>We create a tiny model using the <code>Model</code> and an <code>AgentSet</code>-style agent container. This is just to demonstrate collection APIs.</p>"},{"location":"user-guide/4_datacollector/#saving-the-data-for-later-use","title":"Saving the data for later use\u00b6","text":"<p><code>DataCollector</code> supports multiple storage backends. Files are saved with step number and batch number (e.g., <code>model_step10_batch2.csv</code>) so multiple collects at the same step don\u2019t overwrite.</p> <ul> <li>CSV: <code>storage=\"csv\"</code> \u2192 writes <code>model_step{n}_batch{k}.csv</code>, easy to open anywhere.</li> <li>Parquet: <code>storage=\"parquet\"</code> \u2192 compressed, efficient for large datasets.</li> <li>S3: <code>storage=\"S3-csv\"</code>/<code>storage=\"S3-parquet\"</code> \u2192 saves CSV/Parquet directly to Amazon S3.</li> <li>PostgreSQL: <code>storage=\"postgresql\"</code> \u2192 inserts results into <code>model_data</code> and <code>agent_data</code> tables for querying.</li> </ul>"},{"location":"user-guide/4_datacollector/#writing-to-local-csv","title":"Writing to Local CSV\u00b6","text":"<p>Switch the storage to <code>csv</code> and provide a folder path. Files are written as <code>model_step{n}.csv</code> and <code>agent_step{n}.csv</code>.</p>"},{"location":"user-guide/4_datacollector/#writing-to-local-parquet","title":"Writing to Local Parquet\u00b6","text":"<p>Use <code>parquet</code> for columnar output.</p>"},{"location":"user-guide/4_datacollector/#writing-to-amazon-s3-csv-or-parquet","title":"Writing to Amazon S3 (CSV or Parquet)\u00b6","text":"<p>Set AWS credentials via environment variables or your usual config. Then choose <code>S3-csv</code> or <code>S3-parquet</code> and pass an S3 URI (e.g., <code>s3://my-bucket/experiments/run-1</code>).</p> <p>Note: This cell requires network access &amp; credentials when actually run.</p>"},{"location":"user-guide/4_datacollector/#writing-to-postgresql","title":"Writing to PostgreSQL\u00b6","text":"<p>PostgreSQL requires that the target tables exist and that the expected reporter columns are present. The collector will validate tables/columns up front and raise descriptive errors if something is missing.</p> <p>Below is a minimal schema example. Adjust columns to your configured reporters.</p>"},{"location":"user-guide/4_datacollector/#triggers-conditional-collection","title":"Triggers &amp; Conditional Collection\u00b6","text":"<p>The collector accepts a <code>trigger: Callable[[Model], bool]</code>. When using <code>conditional_collect()</code>, the collector checks the trigger and collects only if it returns <code>True</code>.</p> <p>You can always call <code>collect()</code> to gather data unconditionally.</p>"},{"location":"user-guide/4_datacollector/#troubleshooting","title":"Troubleshooting\u00b6","text":"<ul> <li>ValueError: Please define a storage_uri \u2014 for non-memory backends you must set <code>_storage_uri</code>.</li> <li>Missing columns in table \u2014 check the PostgreSQL error text; create/alter the table to include the columns for your configured <code>model_reporters</code> and <code>agent_reporters</code>, plus required <code>step</code> and <code>seed</code>.</li> <li>Permissions/credentials errors (S3/PostgreSQL) \u2014 ensure correct IAM/credentials or database permissions.</li> </ul>"},{"location":"user-guide/5_benchmarks/","title":"Performance Boost \ud83c\udfce\ufe0f\ud83d\udca8","text":"<p>mesa-frames offers significant performance improvements over the original mesa framework. Here are some benchmark results for different models:</p>"},{"location":"user-guide/5_benchmarks/#boltzmann-wealth-model","title":"Boltzmann Wealth Model \ud83d\udcb0","text":"<p>View the benchmark script</p>"},{"location":"user-guide/5_benchmarks/#comparison-with-mesa","title":"Comparison with mesa","text":""},{"location":"user-guide/5_benchmarks/#comparison-of-mesa-frames-implementations","title":"Comparison of mesa-frames implementations","text":""},{"location":"user-guide/5_benchmarks/#sugarscape-with-instantaneous-growback","title":"SugarScape with Instantaneous Growback \ud83c\udf6c","text":"<p>View the benchmark script</p> <p></p>"}]}